/**
 * Important thing is that no event is fired until `end` happens.
 * This is because of `retry` option which appeared in 0.2 version
 * 
 * In fact `retry` changes everything:
 * in 0.1 mocha-parallel-tests could emit events as soon as they appear.
 * The only limitation is some kind of `currently being executed file`, i.e.
 * we can't emit events in the middle of another test file being processed
 *
 * In 0.2 `retry` options appears and error can happen after 2 successful tests in one suite.
 * Also by this time other files could've finished executing so it's safe to show their events
 * So `mocha-parallel-tests` waits for `end` event and emits accumulated events then
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _base = require('mocha/lib/reporters/base');

var _base2 = _interopRequireDefault(_base);

var _runner = require('./runner');

var _watcher = require('./watcher');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const RUNNER_EVENTS = ['suite', 'suite end', 'test', 'pending', 'pass', 'test end', 'fail', 'failRetry'];

const debugLog = (0, _debug2.default)('mocha-parallel-tests:reporter');
let reporterInstance;
let testsFinished = 0;
let failsOccured = 0;

// save original standard streams methods
// because lib/watcher.js overwites them
const originalWrites = {
    stderr: process.stderr.write.bind(process.stderr),
    stdout: process.stdout.write.bind(process.stdout)
};

// some console.logs are fired before instance of Reporter is created
// so it's better to have some kind of hash table with intercepted messages
const stdMessagesMap = new Map();
_watcher.stdStreamsEmitter.on('message', function (data) {
    if (!stdMessagesMap.has(data.file)) {
        stdMessagesMap.set(data.file, []);
    }

    const fileMessages = stdMessagesMap.get(data.file);
    fileMessages.push({
        streamName: data.streamName,
        message: data.message,
        timestamp: Date.now()
    });

    stdMessagesMap.set(data.file, fileMessages);
});

class AbstractReporter extends _base2.default {
    constructor(runner) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        super(runner);

        this._runnerWrapped = (0, _runner.getInstance)();
        this._runner = runner;
        this._options = options;
        this._eventsNotEmited = []; // array events

        // create "real" reporter to output our runner events
        this._setReporterOnce();

        this._detectFile();
        this._listenToRunnerEvents();

        // start queue
        this._runnerWrapped.start();
    }

    _detectFile() {
        if (this._runner.suite.suites.length) {
            this._testFile = this._runner.suite.suites[0].file;
            this._relativeFilePath = _path2.default.relative(__filename, this._testFile);

            // if fail happens and another try is available
            // clear intercepted messages
            _watcher.stdStreamsEmitter.on('fail', file => stdMessagesMap.delete(file));
        }
    }

    _setReporterOnce() {
        if (reporterInstance) {
            return;
        }

        this._options.reporterName = this._options.reporterName || 'spec';

        const reporterTryPaths = [`mocha/lib/reporters/${ this._options.reporterName }`, this._options.reporterName, _path2.default.resolve(process.cwd(), this._options.reporterName)];

        let UserReporter;
        for (let reporterPath of reporterTryPaths) {
            try {
                UserReporter = require(reporterPath);
                break;
            } catch (evt) {
                // pass
            }
        }

        if (!UserReporter) {
            throw new Error(`Invalid reporter "${ this._options.reporterName }"`);
        }

        reporterInstance = new UserReporter(this._runnerWrapped, this._options);
    }

    _storeEventData(_ref) {
        let eventType = _ref.eventType,
            args = _ref.args;

        debugLog(`${ eventType } event fired (${ this._relativeFilePath })`);

        this._eventsNotEmited.push({
            type: eventType,
            data: args,
            timestamp: Date.now()
        });
    }

    _listenToRunnerEvents() {
        var _this = this;

        for (let eventType of RUNNER_EVENTS) {
            this._runner.on(eventType, function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                _this._storeEventData({ eventType, args });

                if (eventType === 'fail') {
                    failsOccured++;
                } else if (eventType === 'failRetry') {
                    failsOccured--;
                }
            });
        }

        this._runner.on('end', () => {
            debugLog(`end event fired (${ this._relativeFilePath })`);

            // combine stored events and intercepted messages
            const allEvents = [];

            // first append all runner events
            this._eventsNotEmited.forEach((eventData, index) => {
                allEvents.push({
                    type: 'runnerEvent',
                    payload: {
                        type: eventData.type,
                        data: eventData.data
                    },
                    meta: {
                        index,
                        timestamp: eventData.timestamp
                    }
                });
            });

            // then append all standard streams messages
            (stdMessagesMap.get(this._testFile) || []).forEach((data, index) => {
                allEvents.push({
                    type: 'stdStreamMessage',
                    payload: {
                        streamName: data.streamName,
                        message: data.message
                    },
                    meta: {
                        index,
                        timestamp: data.timestamp
                    }
                });
            });

            // sort all events by timestamp and re-emit
            allEvents.sort((a, b) => {
                const timestampDiff = a.meta.timestamp - b.meta.timestamp;

                if (timestampDiff) {
                    return timestampDiff;
                }

                const aEventWeight = a.type === 'runnerEvent' ? 1 : 0;
                const bEventWeight = b.type === 'runnerEvent' ? 1 : 0;
                const weightDiff = aEventWeight - bEventWeight;

                if (weightDiff) {
                    return weightDiff;
                }

                return a.meta.index - b.meta.index;
            }).forEach(eventData => {
                if (eventData.type === 'runnerEvent') {
                    var _runnerWrapped;

                    (_runnerWrapped = this._runnerWrapped).emit.apply(_runnerWrapped, [eventData.payload.type].concat(_toConsumableArray(eventData.payload.data)));
                } else if (eventData.type === 'stdStreamMessage') {
                    originalWrites[eventData.payload.streamName](eventData.payload.message);
                }
            });

            testsFinished++;

            if (testsFinished === this._options.testsLength) {
                this._runnerWrapped.end(failsOccured);
            }
        });
    }
}

exports.default = AbstractReporter;
module.exports = exports['default'];