'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// files lookup in mocha is complex, so it's better to just run original code


exports.default = binHelper;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _reporter = require('./lib/reporter');

var _reporter2 = _interopRequireDefault(_reporter);

var _runner = require('./lib/runner');

var _prepareRequire = require('./lib/utils/prepare-require');

var _prepareRequire2 = _interopRequireDefault(_prepareRequire);

var _requireCacheWatcher = require('./lib/utils/require-cache-watcher');

var _requireCacheWatcher2 = _interopRequireDefault(_requireCacheWatcher);

var _hooks = require('./lib/utils/hooks');

var _watcher = require('./lib/watcher');

var _utils = require('mocha/lib/utils');

var _processRequireOption = require('./lib/utils/process-require-option');

var _processRequireOption2 = _interopRequireDefault(_processRequireOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function binHelper(options) {
    process.setMaxListeners(0);

    if (typeof options.compilers === 'string') {
        options.compilers = [options.compilers];
    }

    const extensions = ['js'];
    (options.compilers || []).forEach(compiler => {
        var _compiler$split = compiler.split(':'),
            _compiler$split2 = _slicedToArray(_compiler$split, 2);

        const ext = _compiler$split2[0],
              mod = _compiler$split2[1];

        let compilerMod = mod;

        if (mod[0] === '.') {
            compilerMod = _path2.default.join(process.cwd(), mod);
        }

        require((0, _prepareRequire2.default)(compilerMod));
        extensions.push(ext);
    });

    // require --require'd files
    (0, _processRequireOption2.default)(options);

    // get test files with original mocha utils.lookupFiles() function
    let files = [];
    (options._ || []).slice(2).forEach(testPath => {
        files = files.concat((0, _utils.lookupFiles)(testPath, extensions, options.recursive));
    });

    // time to create our own runner
    const customRunner = (0, _runner.createInstance)();

    // watcher monitors running files
    (0, _watcher.setOptions)({
        maxParallelTests: options.maxParallel,
        retryCount: options.retry
    });

    // require(testFile) needs some global hooks (describe, it etc)
    (0, _hooks.patch)();

    const cacheWatcher = new _requireCacheWatcher2.default();
    cacheWatcher.start();

    files.forEach(file => {
        // does this file have a syntax error?
        // require() will show that
        const absFilePath = _path2.default.resolve(file);
        require(absFilePath);

        (0, _watcher.addTest)(absFilePath);
    });

    // okay, all files are valid JavaScript
    // now it's time for mocha to set its own global hooks
    (0, _hooks.restore)();

    // also we need to delete files from require.cache
    // which are involved into all tests
    const cacheMark = cacheWatcher.getStateMark();
    cacheWatcher.flushRequireCache(cacheMark);

    (0, _watcher.runTests)({
        options: Object.assign({}, options, {
            reporterName: options.R || options.reporter,
            reporter: _reporter2.default,
            testsLength: files.length
        })
    });

    return new Promise(resolve => {
        customRunner.on('end', resolve);
    });
}
module.exports = exports['default'];